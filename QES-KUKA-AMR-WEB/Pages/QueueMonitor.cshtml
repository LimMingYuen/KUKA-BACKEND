@page
@model QES_KUKA_AMR_WEB.Pages.QueueMonitorModel
@{
    ViewData["Title"] = "Mission Queue Monitor";
    Layout = "~/Pages/Shared/_DashboardLayout.cshtml";
}

<div class="container-fluid">
    <div class="d-flex justify-content-between align-items-center mb-4">
        <div>
            <h2 class="mb-1">Mission Queue Monitor</h2>
            <p class="text-muted mb-0" style="font-size: 14px;">Monitor and manage queued missions in real-time</p>
        </div>
        <div class="auto-refresh-toggle">
            <span class="refresh-indicator" id="refreshIndicator"></span>
            <span id="refreshStatus">Auto-refreshing every 3s</span>
        </div>
    </div>

    <!-- Statistics Cards -->
    <div class="stats-container" id="statsContainer">
        <div class="stat-card stat-queued">
            <p>Queued</p>
            <h3 id="statQueued">-</h3>
        </div>
        <div class="stat-card stat-processing">
            <p>Processing</p>
            <h3 id="statProcessing">-</h3>
        </div>
        <div class="stat-card stat-available">
            <p>Available Slots</p>
            <h3 id="statAvailable">-</h3>
        </div>
    </div>

    <!-- Search and Filter Section -->
    <div class="filter-section mb-3">
        <div class="d-flex gap-2 align-items-center flex-wrap">
            <div class="search-group flex-grow-1">
                <input type="text"
                       id="searchInput"
                       placeholder="Search by mission code, workflow, request ID, or created by..."
                       class="search-input"
                       onkeyup="handleSearchKeyup(event)" />
            </div>

            <select class="form-select" style="width: auto; min-width: 150px;" id="statusFilter" onchange="filterByStatus()">
                <option value="">All Statuses</option>
                <option value="0">Queued</option>
                <option value="1">Processing</option>
            </select>

            <button type="button" class="btn-clear" onclick="clearSearch()" id="clearSearchBtn" style="display: none;">
                <span>&#10005;</span> Clear
            </button>
        </div>

        <div id="filterIndicator" class="filter-indicator mt-2" style="display: none;"></div>
    </div>



    <!-- Queue Table -->
    <div class="table-container table-scroll-queue">
        <div class="table-responsive">
            <table class="data-table" id="queueTable">
                <thead>
                    <tr>
                        <th><a href="#" onclick="sortBy('id'); return false;" class="sortable-column">ID <span id="sort-id" class="sort-icon"></span></a></th>
                        <th><a href="#" onclick="sortBy('missioncode'); return false;" class="sortable-column">Mission Code <span id="sort-missioncode" class="sort-icon"></span></a></th>
                        <th><a href="#" onclick="sortBy('workflowname'); return false;" class="sortable-column">Workflow <span id="sort-workflowname" class="sort-icon"></span></a></th>
                        <th><a href="#" onclick="sortBy('priority'); return false;" class="sortable-column">Priority <span id="sort-priority" class="sort-icon"></span></a></th>
                        <th><a href="#" onclick="sortBy('status'); return false;" class="sortable-column">Status <span id="sort-status" class="sort-icon"></span></a></th>
                        <th><a href="#" onclick="sortBy('createddate'); return false;" class="sortable-column">Created <span id="sort-createddate" class="sort-icon"></span></a></th>
                        <th><a href="#" onclick="sortBy('processeddate'); return false;" class="sortable-column">Processed <span id="sort-processeddate" class="sort-icon"></span></a></th>
                        <th><a href="#" onclick="sortBy('createdby'); return false;" class="sortable-column">Created By <span id="sort-createdby" class="sort-icon"></span></a></th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="queueTableBody">
                    <tr>
                        <td colspan="9" class="text-center py-4">
                            <div style="font-size: 3rem; opacity: 0.3; margin-bottom: 1rem;">‚è≥</div>
                            <p>Loading queue data...</p>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Pagination Footer -->
        <div class="pagination-section" id="paginationSection" style="display: none;">
            <div class="pagination-info">
                <span class="page-info" id="pageInfo">Showing 0-0 of 0 records</span>
            </div>

            <div class="pagination-controls" id="paginationControls"></div>

            <div class="page-size-selector">
                <label class="items-label">Items per page:</label>
                <select id="pageSizeSelector" class="items-per-page" onchange="changePageSize(this.value)">
                    <option value="10">10</option>
                    <option value="20" selected>20</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                </select>
            </div>
        </div>
    </div>
</div>

<script>
    let autoRefreshInterval = null;
    let currentFilter = '';
    let currentSearchTerm = '';
    let lastRefreshError = null;
    let currentSortColumn = 'createddate';
    let currentSortDirection = 'asc';
    let currentPage = 1;
    let currentPageSize = 20;
    let totalPages = 1;
    let totalCount = 0;

    const DEBUG_QUEUE_MONITOR = false;
    const debugEvents = [];
    const BROADCAST_STORAGE_KEY = 'amr-queue-updates-temp';
    const BROADCAST_SESSION_QUEUE_KEY = 'amrQueueUpdates';
    const queueBroadcastChannel = ('BroadcastChannel' in window)
        ? new BroadcastChannel('amr-queue-updates')
        : null;
    let pendingBroadcastRefresh = null;

    if (queueBroadcastChannel) {
        queueBroadcastChannel.addEventListener('message', handleQueueBroadcastMessage);
    }
    window.addEventListener('storage', handleQueueStorageEvent);

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
        hydrateFromPendingQueueUpdates();
        updateSortIndicators();
        updateFilterIndicator();
        refreshQueue();
        startAutoRefresh();
    });

    function startAutoRefresh() {
        autoRefreshInterval = setInterval(() => {
            refreshQueue();
        }, 3000); // Refresh every 3 seconds
    }

    function stopAutoRefresh() {
        if (autoRefreshInterval) {
            clearInterval(autoRefreshInterval);
            autoRefreshInterval = null;
        }
    }

    function sortBy(column) {
        if (currentSortColumn === column) {
            currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
        } else {
            currentSortColumn = column;
            currentSortDirection = 'asc';
        }
        currentPage = 1; // Reset to first page when sorting
        updateSortIndicators();
        refreshQueue();
    }

    function updateSortIndicators() {
        // Reset all sort icons
        document.querySelectorAll('.sort-icon').forEach(icon => {
            icon.className = 'sort-icon';
        });

        // Set active sort icon
        const activeIcon = document.getElementById(`sort-${currentSortColumn}`);
        if (activeIcon) {
            activeIcon.className = `sort-icon ${currentSortDirection}`;
        }
    }

    function changePage(page) {
        currentPage = page;
        refreshQueue();
    }

    function changePageSize(size) {
        currentPageSize = parseInt(size);
        currentPage = 1; // Reset to first page
        refreshQueue();
    }

    async function refreshQueue() {
        try {
            debugLog('refresh:start', { filter: currentFilter, sort: currentSortColumn, direction: currentSortDirection, page: currentPage });

            const statsResponse = await fetch('?handler=Stats', { cache: 'no-store' });
            debugLog('refresh:stats:response', serializeResponse(statsResponse));

            if (!statsResponse.ok) {
                handleRefreshError(`Failed to retrieve queue stats (HTTP ${statsResponse.status})`);
                return;
            }

            const stats = await statsResponse.json();
            debugLog('refresh:stats:payload', stats);

            if (!isValidStats(stats)) {
                handleRefreshError('Queue stats response was in an unexpected format.');
                return;
            }
            updateStats(stats);

            const queueUrl = buildQueueUrl();
            const queueResponse = await fetch(queueUrl, { cache: 'no-store' });
            debugLog('refresh:queue:response', serializeResponse(queueResponse, queueUrl));

            if (!queueResponse.ok) {
                handleRefreshError(`Failed to retrieve queue items (HTTP ${queueResponse.status})`);
                return;
            }

            const result = await queueResponse.json();
            debugLog('refresh:queue:payload', result);

            if (!result || !Array.isArray(result.items)) {
                handleRefreshError('Queue response was in an unexpected format.');
                return;
            }

            const activeItems = result.items;

            totalCount = result.totalCount || 0;
            totalPages = result.totalPages || 1;
            currentPage = result.page || 1;

            updateQueueTable(activeItems);
            updatePagination();
            clearRefreshError();
            debugLog('refresh:complete', { totalItems: result.items.length, activeItems: activeItems.length, filteredOut: result.items.length - activeItems.length });
        } catch (error) {
            handleRefreshError('Error refreshing queue. See console for details.', error);
        }
    }

    function buildQueueUrl() {
        const params = new URLSearchParams();
        params.append('handler', 'Queue');
        if (currentFilter) params.append('status', currentFilter);
        if (currentSearchTerm) params.append('searchTerm', currentSearchTerm);
        params.append('sortColumn', currentSortColumn);
        params.append('sortDirection', currentSortDirection);
        params.append('page', currentPage.toString());
        params.append('pageSize', currentPageSize.toString());
        return `?${params.toString()}`;
    }

    function applySearch() {
        const searchInput = document.getElementById('searchInput');
        currentSearchTerm = searchInput.value.trim();
        currentPage = 1; // Reset to first page
        updateFilterIndicator();
        refreshQueue();
    }

    function clearSearch() {
        const searchInput = document.getElementById('searchInput');
        const statusFilter = document.getElementById('statusFilter');

        searchInput.value = '';
        statusFilter.value = '';
        currentSearchTerm = '';
        currentFilter = '';
        currentPage = 1;

        updateFilterIndicator();
        refreshQueue();
    }

    // Debounce timer for search
    let searchDebounceTimer;

    function handleSearchKeyup(event) {
        // Still allow Enter key to trigger immediate search
        if (event.key === 'Enter') {
            clearTimeout(searchDebounceTimer);
            applySearch();
            return;
        }

        // Auto-search with debouncing (300ms delay)
        clearTimeout(searchDebounceTimer);
        searchDebounceTimer = setTimeout(() => {
            applySearch();
        }, 300);
    }

    function updateFilterIndicator() {
        const indicator = document.getElementById('filterIndicator');
        const clearBtn = document.getElementById('clearSearchBtn');
        const hasFilters = currentSearchTerm || currentFilter;

        if (hasFilters) {
            let badges = [];

            if (currentSearchTerm) {
                badges.push(`<span class="badge bg-info me-1"><span>&#128269;</span> Search: "${currentSearchTerm}"</span>`);
            }

            if (currentFilter) {
                const statusName = getStatusInfo(parseInt(currentFilter)).name;
                badges.push(`<span class="badge bg-info"><span>&#128190;</span> Status: ${statusName}</span>`);
            }

            indicator.innerHTML = badges.join('');
            indicator.style.display = 'block';
            clearBtn.style.display = 'inline-flex';
        } else {
            indicator.style.display = 'none';
            clearBtn.style.display = 'none';
        }
    }

    function updatePagination() {
        const paginationSection = document.getElementById('paginationSection');
        const pageInfo = document.getElementById('pageInfo');
        const paginationControls = document.getElementById('paginationControls');

        if (totalCount === 0) {
            paginationSection.style.display = 'none';
            return;
        }

        paginationSection.style.display = 'flex';

        // Update page info
        const displayStart = totalCount === 0 ? 0 : ((currentPage - 1) * currentPageSize) + 1;
        const displayEnd = Math.min(currentPage * currentPageSize, totalCount);
        pageInfo.textContent = `Showing ${displayStart}-${displayEnd} of ${totalCount} records`;

        // Build pagination controls
        let html = '';

        // Previous button
        if (currentPage > 1) {
            html += `<a href="#" onclick="changePage(${currentPage - 1}); return false;" class="btn-page">&laquo; Previous</a>`;
        } else {
            html += `<button class="btn-page" disabled>&laquo; Previous</button>`;
        }

        // Page numbers
        html += '<div class="page-numbers">';
        const startPage = Math.max(1, currentPage - 2);
        const endPage = Math.min(totalPages, currentPage + 2);

        if (startPage > 1) {
            html += `<a href="#" onclick="changePage(1); return false;" class="btn-page">1</a>`;
            if (startPage > 2) {
                html += '<span class="page-ellipsis">...</span>';
            }
        }

        for (let i = startPage; i <= endPage; i++) {
            if (i === currentPage) {
                html += `<button class="btn-page active">${i}</button>`;
            } else {
                html += `<a href="#" onclick="changePage(${i}); return false;" class="btn-page">${i}</a>`;
            }
        }

        if (endPage < totalPages) {
            if (endPage < totalPages - 1) {
                html += '<span class="page-ellipsis">...</span>';
            }
            html += `<a href="#" onclick="changePage(${totalPages}); return false;" class="btn-page">${totalPages}</a>`;
        }
        html += '</div>';

        // Next button
        if (currentPage < totalPages) {
            html += `<a href="#" onclick="changePage(${currentPage + 1}); return false;" class="btn-page">Next &raquo;</a>`;
        } else {
            html += `<button class="btn-page" disabled>Next &raquo;</button>`;
        }

        paginationControls.innerHTML = html;
    }

    function updateStats(stats) {
        if (!isValidStats(stats)) {
            document.getElementById('statQueued').textContent = '-';
            document.getElementById('statProcessing').textContent = '-';
            document.getElementById('statAvailable').textContent = '-/-';
            return;
        }

        document.getElementById('statQueued').textContent = stats.queuedCount;
        document.getElementById('statProcessing').textContent = stats.processingCount;
        document.getElementById('statAvailable').textContent = `${stats.availableSlots}/${stats.totalSlots}`;
    }

    function updateQueueTable(queue) {
        const tbody = document.getElementById('queueTableBody');

        if (!Array.isArray(queue)) {
            debugLog('queue:render:error', { reason: 'queue-not-array', queue });
            renderQueueError(tbody, 'Unable to display queue items right now.');
            return;
        }

        if (!queue || queue.length === 0) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="9" class="text-center py-4">
                        <div style="font-size: 3rem; opacity: 0.3; margin-bottom: 1rem;">üìã</div>
                        <p>No missions in queue</p>
                    </td>
                </tr>
            `;
            return;
        }

        tbody.innerHTML = queue.map(item => {
            if (!item || typeof item !== 'object') {
                debugLog('queue:item:invalid', { item });
                return '';
            }

            const statusInfo = getStatusInfo(item.status);
            const createdDate = new Date(item.createdDate).toLocaleString();
            const processedDate = item.processedDate ? new Date(item.processedDate).toLocaleString() : '-';

            const actions = getActionsForStatus(item.status, item.id);

            return `
                <tr>
                    <td>${item.id}</td>
                    <td><code>${item.missionCode}</code></td>
                    <td>
                        <div>${item.workflowName}</div>
                        <small class="text-muted">${item.workflowCode}</small>
                    </td>
                    <td>
                        ${item.status === 0 ? `
                            <div class="priority-control">
                                <input type="number" class="priority-input" value="${item.priority}"
                                       onchange="updatePriority(${item.id}, this.value)" min="0" max="10">
                                <div class="priority-buttons">
                                    <button class="btn-priority btn-priority-high" onclick="updateSmartPriority(${item.id}, 'high')" title="Set to High Priority (0-3)">H</button>
                                    <button class="btn-priority btn-priority-medium" onclick="updateSmartPriority(${item.id}, 'medium')" title="Set to Medium Priority (5)">M</button>
                                    <button class="btn-priority btn-priority-low" onclick="updateSmartPriority(${item.id}, 'low')" title="Set to Low Priority (8-10)">L</button>
                                </div>
                            </div>
                        ` : `<div class="priority-display"><span class="badge bg-secondary">${item.priority}</span></div>`}
                    </td>
                    <td><span class="status-badge ${statusInfo.cssClass}">${statusInfo.name}</span></td>
                    <td><small>${createdDate}</small></td>
                    <td><small>${processedDate}</small></td>
                    <td>${item.createdBy}</td>
                    <td>
                        <div class="action-buttons">
                            ${actions}
                        </div>
                    </td>
                </tr>
            `;
        }).join('');
    }

    function getStatusInfo(status) {
        switch(status) {
            case 0: return { name: 'Queued', cssClass: 'status-queued' };
            case 1: return { name: 'Processing', cssClass: 'status-processing' };
            case 2: return { name: 'Completed', cssClass: 'status-complete' };
            case 3: return { name: 'Failed', cssClass: 'status-failed' };
            case 4: return { name: 'Cancelled', cssClass: 'status-cancelled' };
            default: return { name: 'Unknown', cssClass: 'status-queued' };
        }
    }

    function getActionsForStatus(status, queueId) {
        if (typeof queueId !== 'number') {
            return '-';
        }

        if (status === 0) { // Queued
            return `<button class="btn btn-sm btn-danger" onclick="removeFromQueue(${queueId})">Remove</button>`;
        } else if (status === 1) { // Processing
            return '-';
        } else {
            return '-';
        }
    }

    async function updatePriority(queueId, newPriority) {
        try {
            debugLog('priority:update:start', { queueId, newPriority });

            const response = await fetch('?handler=UpdatePriority', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ queueId, priority: parseInt(newPriority) })
            });

            debugLog('priority:update:response', serializeResponse(response));

            const result = await response.json();
            debugLog('priority:update:payload', result);

            if (result.success) {
                showMessage('success', 'Priority updated successfully');
                await refreshQueue();
            } else {
                showMessage('danger', result.message || 'Failed to update priority');
            }
        } catch (error) {
            console.error('Error updating priority:', error);
            debugLog('priority:update:error', serializeError(error));
            showMessage('danger', 'Network error');
        }
    }

    async function updateSmartPriority(queueId, priorityLevel) {
        try {
            debugLog('priority:smart-update:start', { queueId, priorityLevel });

            const response = await fetch('?handler=UpdateSmartPriority', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ queueId, priorityLevel })
            });

            debugLog('priority:smart-update:response', serializeResponse(response));

            const result = await response.json();
            debugLog('priority:smart-update:payload', result);

            if (result.success) {
                const priorityLabel = priorityLevel.charAt(0).toUpperCase() + priorityLevel.slice(1);
                showMessage('success', `Priority set to ${result.assignedPriority} (${priorityLabel})`);
                await refreshQueue();
            } else {
                showMessage('danger', result.message || 'Failed to update priority');
            }
        } catch (error) {
            console.error('Error updating smart priority:', error);
            debugLog('priority:smart-update:error', serializeError(error));
            showMessage('danger', 'Network error');
        }
    }

    async function removeFromQueue(queueId) {
        if (!confirm('Are you sure you want to remove this mission from the queue?')) {
            return;
        }

        try {
            debugLog('queue:remove:start', { queueId });

            const response = await fetch(`?handler=Remove&queueId=${queueId}`, {
                method: 'DELETE'
            });

            debugLog('queue:remove:response', serializeResponse(response));

            const result = await response.json();
            debugLog('queue:remove:payload', result);

            if (result.success) {
                showMessage('success', 'Mission removed from queue');
                await refreshQueue();
            } else {
                showMessage('danger', result.message || 'Failed to remove mission');
            }
        } catch (error) {
            console.error('Error removing mission:', error);
            debugLog('queue:remove:error', serializeError(error));
            showMessage('danger', 'Network error');
        }
    }


    function filterByStatus() {
        const select = document.getElementById('statusFilter');
        currentFilter = select.value;
        currentPage = 1; // Reset to first page
        updateFilterIndicator();
        refreshQueue();
    }

    function handleRefreshError(message, error) {
        if (error) {
            console.error('Queue refresh error:', error);
        } else {
            console.warn(message);
        }

        debugLog('refresh:error', { message, error: serializeError(error), filter: currentFilter });

        if (lastRefreshError !== message) {
            showMessage('warning', message);
            lastRefreshError = message;
        }

        const tbody = document.getElementById('queueTableBody');
        renderQueueError(tbody, message);
    }

    function clearRefreshError() {
        if (lastRefreshError !== null) {
            lastRefreshError = null;
        }
    }

    function renderQueueError(tbody, message) {
        if (!tbody) {
            return;
        }

        tbody.innerHTML = `
            <tr>
                <td colspan="9" class="text-center py-4">
                    <div style="font-size: 3rem; opacity: 0.3; margin-bottom: 1rem;">‚ö†</div>
                    <p>${message}</p>
                </td>
            </tr>
        `;
    }

    function isValidStats(stats) {
        if (!stats || typeof stats !== 'object') {
            return false;
        }

        const expectedKeys = ['queuedCount', 'processingCount', 'availableSlots', 'totalSlots'];
        return expectedKeys.every(key => typeof stats[key] === 'number');
    }

    function handleQueueBroadcastMessage(event) {
        processQueueUpdateMessage(event?.data, 'broadcast-channel');
    }

    function handleQueueStorageEvent(event) {
        if (event.key !== BROADCAST_STORAGE_KEY || !event.newValue) {
            return;
        }

        try {
            const data = JSON.parse(event.newValue);
            processQueueUpdateMessage(data, 'storage-event');
        } catch (error) {
            console.warn('Queue monitor storage event parse error', error);
        }
    }

    function processQueueUpdateMessage(message, source) {
        if (!message || message.type !== 'queue:mission-updated') {
            return;
        }

        debugLog('broadcast:received', { source, message });
        scheduleBroadcastRefresh(message.payload);
    }

    function scheduleBroadcastRefresh(payload) {
        if (!payload) {
            debugLog('broadcast:payload-missing', {});
            if (!pendingBroadcastRefresh) {
                queueRefreshAfterDelay('unknown', 'updated', null);
            }
            return;
        }

        const missionCode = payload.missionCode || 'unknown';
        const statusName = payload.statusName || 'updated';

        queueRefreshAfterDelay(missionCode, statusName, payload);
    }

    function queueRefreshAfterDelay(missionCode, statusName, payload) {
        if (pendingBroadcastRefresh) {
            debugLog('broadcast:refresh-skipped', { reason: 'pending', missionCode, statusName });
            return;
        }

        if (payload && payload.missionCode) {
            showMessage('info', `Mission ${missionCode} ${statusName}. Refreshing queue...`);
        } else {
            showMessage('info', 'Queue update received. Refreshing queue...');
        }

        pendingBroadcastRefresh = setTimeout(() => {
            pendingBroadcastRefresh = null;
            debugLog('broadcast:refresh-execute', { missionCode, statusName });
            refreshQueue();
        }, 250);
    }

    function showMessage(type, message) {
        const toast = document.createElement('div');
        toast.className = `alert alert-${type} position-fixed top-0 end-0 m-3`;
        toast.style.zIndex = '9999';
        toast.textContent = message;
        document.body.appendChild(toast);

        setTimeout(() => {
            toast.remove();
        }, 3000);
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
        stopAutoRefresh();
        if (queueBroadcastChannel) {
            queueBroadcastChannel.removeEventListener('message', handleQueueBroadcastMessage);
            queueBroadcastChannel.close();
        }
        window.removeEventListener('storage', handleQueueStorageEvent);
    });

    function debugLog(event, payload) {
        if (!DEBUG_QUEUE_MONITOR) {
            return;
        }

        const timestamp = new Date().toISOString();
        const entry = { timestamp, event, payload };
        debugEvents.push(entry);

        if (debugEvents.length > 50) {
            debugEvents.shift();
        }

        if (event.includes('error')) {
            console.error('[QueueMonitor]', timestamp, event, payload);
        } else {
            console.debug('[QueueMonitor]', timestamp, event, payload);
        }
    }

    function hydrateFromPendingQueueUpdates() {
        try {
            const stored = sessionStorage.getItem(BROADCAST_SESSION_QUEUE_KEY);
            if (!stored) {
                return;
            }

            const queued = JSON.parse(stored);
            if (!Array.isArray(queued) || queued.length === 0) {
                sessionStorage.removeItem(BROADCAST_SESSION_QUEUE_KEY);
                return;
            }

            debugLog('hydrate:pending-updates', { count: queued.length });

            queued.forEach(payload => {
                scheduleBroadcastRefresh(payload);
            });

            sessionStorage.removeItem(BROADCAST_SESSION_QUEUE_KEY);
        } catch (error) {
            console.warn('Failed to hydrate pending queue updates', error);
        }
    }

    function serializeResponse(response, urlOverride) {
        if (!response) {
            return { status: 'no-response' };
        }

        return {
            url: urlOverride || response.url,
            ok: response.ok,
            status: response.status,
            statusText: response.statusText,
            redirected: response.redirected,
            type: response.type
        };
    }

    function serializeError(error) {
        if (!error) {
            return null;
        }

        return {
            name: error.name,
            message: error.message,
            stack: error.stack
        };
    }
</script>
