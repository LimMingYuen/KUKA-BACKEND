@page
@model QES_KUKA_AMR_WEB.Pages.WorkflowMonitorModel
@{
    ViewData["Title"] = Model.Mission != null ? $"{Model.Mission.MissionName} - Workflow Monitor" : "Workflow Monitor";
    Layout = "_DashboardLayout";
}

@section Styles {
    <style>
        .workflow-monitor {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            min-height: calc(100vh - 100px);
        }

        .workflow-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 2px solid #e2e8f0;
        }

        .workflow-header-left {
            flex: 1;
        }

        .workflow-title {
            font-size: 28px;
            font-weight: 600;
            color: #1a202c;
            margin: 0 0 8px 0;
        }

        .workflow-description {
            color: #718096;
            font-size: 14px;
            margin: 0;
        }

        .back-btn {
            padding: 8px 16px;
            background: #e2e8f0;
            color: #2d3748;
            border: none;
            border-radius: 6px;
            text-decoration: none;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .back-btn:hover {
            background: #cbd5e0;
            color: #1a202c;
        }

        .workflow-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 24px;
            align-items: start;
        }

        .flowchart-section {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            min-height: 600px;
        }

        .flowchart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .flowchart-title {
            font-size: 18px;
            font-weight: 600;
            color: #2d3748;
            margin: 0;
        }

        .layout-toggle-btn {
            background: white;
            border: 1px solid #cbd5e0;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            color: #4a5568;
            transition: all 0.2s;
        }

        .layout-toggle-btn:hover {
            background: #f7fafc;
            border-color: #a0aec0;
        }

        .flowchart-container {
            background: #f7fafc;
            border-radius: 8px;
            padding: 20px;
            min-height: 500px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 20px;
        }

        .control-section {
            margin-bottom: 24px;
            padding-bottom: 24px;
            border-bottom: 1px solid #e2e8f0;
        }

        .control-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .control-section-title {
            font-size: 14px;
            font-weight: 600;
            color: #4a5568;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 0 0 12px 0;
        }

        .status-display {
            background: #f7fafc;
            border-radius: 8px;
            padding: 16px;
            text-align: center;
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 12px;
        }

        .status-icon {
            font-size: 20px;
        }

        .status-idle { background: #e2e8f0; color: #4a5568; }
        .status-created { background: #e0e7ff; color: #3730a3; }
        .status-executing { background: #dbeafe; color: #1e40af; }
        .status-waiting { background: #fef3c7; color: #92400e; }
        .status-cancelling { background: #fed7aa; color: #9a3412; }
        .status-complete { background: #d1fae5; color: #065f46; }
        .status-cancelled { background: #fee2e2; color: #991b1b; }
        .status-warning { background: #fef3c7; color: #92400e; }
        .status-error { background: #fee2e2; color: #991b1b; }
        .status-unknown { background: #f3f4f6; color: #374151; }

        .status-details {
            font-size: 13px;
            color: #718096;
        }

        .status-details div {
            margin: 4px 0;
        }

        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-start {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            margin-bottom: 12px;
        }

        .btn-start:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }

        .btn-cancel {
            background: #ef4444;
            color: white;
        }

        .btn-cancel:hover:not(:disabled) {
            background: #dc2626;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }

        .btn-group-wrapper {
            position: relative;
            width: 100%;
        }

        .btn-cancel.dropdown-toggle {
            width: 100%;
        }

        .btn-cancel.dropdown-toggle::after {
            margin-left: 8px;
        }

        .dropdown-menu {
            width: 100%;
            margin-top: 4px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .dropdown-item {
            padding: 12px 16px;
            transition: background-color 0.2s;
        }

        .dropdown-item:hover {
            background-color: #f3f4f6;
        }

        .dropdown-item strong {
            display: block;
            color: #1a202c;
            font-size: 14px;
            margin-bottom: 2px;
        }

        .dropdown-item small {
            display: block;
            font-size: 12px;
        }

        .mission-info {
            font-size: 13px;
            color: #4a5568;
        }

        .mission-info-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e2e8f0;
        }

        .mission-info-row:last-child {
            border-bottom: none;
        }

        .mission-info-label {
            font-weight: 500;
            color: #718096;
        }

        .mission-info-value {
            font-weight: 600;
            color: #2d3748;
        }

        .progress-section {
            background: #f7fafc;
            border-radius: 8px;
            padding: 16px;
        }

        .progress-label {
            font-size: 12px;
            color: #718096;
            margin-bottom: 8px;
        }

        .progress-bar-container {
            background: #e2e8f0;
            border-radius: 4px;
            height: 8px;
            overflow: hidden;
        }

        .progress-bar {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 14px;
            font-weight: 600;
            color: #2d3748;
            margin-top: 8px;
            text-align: center;
        }

        .current-step-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .current-step-card h4 {
            margin: 0 0 12px 0;
            font-size: 16px;
            font-weight: 600;
        }

        .current-step-card .step-info {
            font-size: 13px;
            margin: 8px 0;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .current-step-card .step-info strong {
            color: #e2e8f0;
            font-weight: 600;
        }

        .current-step-card .step-info code {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            color: #fff;
            font-family: monospace;
            font-size: 12px;
        }

        .manual-notice {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid #ffc107;
            border-radius: 4px;
            padding: 8px;
            margin-top: 8px;
            font-size: 13px;
            font-weight: 500;
        }

        .text-muted {
            color: rgba(255, 255, 255, 0.7) !important;
            font-size: 12px;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }

        @@keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #9ca3af;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .mermaid-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        .mermaid-container svg {
            max-width: 100%;
            height: auto;
        }

        @@media (max-width: 1200px) {
            .workflow-content {
                grid-template-columns: 1fr;
            }

            .control-panel {
                position: relative;
                top: 0;
            }
        }
    </style>
}

<div class="workflow-monitor">
    @if (Model.Mission == null)
    {
        <div class="empty-state">
            <div class="empty-state-icon">‚ö†Ô∏è</div>
            <h3>Mission Not Found</h3>
            <p>@Model.ErrorMessage</p>
            <a href="/SavedCustomMissions" class="back-btn">‚Üê Back to Missions</a>
        </div>
    }
    else
    {
        <div class="workflow-header">
            <div class="workflow-header-left">
                <h1 class="workflow-title">@Model.Mission.MissionName</h1>
                @if (!string.IsNullOrEmpty(Model.Mission.Description))
                {
                    <p class="workflow-description">@Model.Mission.Description</p>
                }
            </div>
            <a href="/SavedCustomMissions" class="back-btn">‚Üê Back to List</a>
        </div>

        <div class="workflow-content">
            <!-- Flowchart Section -->
            <div class="flowchart-section">
                <div class="flowchart-header">
                    <h2 class="flowchart-title">üó∫Ô∏è Mission Flow</h2>
                    <button type="button" class="layout-toggle-btn" onclick="toggleLayout()">
                        <span id="layoutIcon">‚¨ç</span>
                        <span id="layoutText">Horizontal</span>
                    </button>
                </div>
                <div class="flowchart-container" id="flowchartContainer">
                    <div class="empty-state">
                        <div class="spinner"></div>
                        <p style="margin-top: 16px;">Loading flowchart...</p>
                    </div>
                </div>
            </div>

            <!-- Control Panel -->
            <div class="control-panel">
                <!-- Status Section -->
                <div class="control-section">
                    <h3 class="control-section-title">Status</h3>
                    <div class="status-display">
                        <div class="status-badge status-idle" id="statusBadge">
                            <span class="status-icon" id="statusIcon">‚èπ</span>
                            <span id="statusText">Idle</span>
                        </div>
                        <div class="status-details" id="statusDetails">
                            <div>Robot: <strong id="robotId">-</strong></div>
                            <div>Position: <strong id="currentPosition">-</strong></div>
                            <div>Progress: <strong id="stepProgress">-</strong></div>
                            <div>Battery: <strong id="batteryLevel">-</strong></div>
                            <div>Duration: <strong id="duration">-</strong></div>
                        </div>
                    </div>
                </div>

                <!-- Current Step Details Section -->
                <div class="control-section" id="currentStepDetails" style="display: none;">
                    <!-- Current step details will be inserted here dynamically -->
                </div>

                <!-- Actions Section -->
                <div class="control-section">
                    <h3 class="control-section-title">Actions</h3>
                    <button type="button" class="btn btn-start" id="startBtn" onclick="startMission()">
                        <span>‚ñ∂Ô∏è</span>
                        <span id="startBtnText">Start Mission</span>
                        <span class="spinner" id="startSpinner" style="display: none;"></span>
                    </button>

                    <!-- Cancel Dropdown Button Group -->
                    <div class="btn-group-wrapper">
                        <button type="button" class="btn btn-cancel dropdown-toggle" id="cancelBtn" data-bs-toggle="dropdown" aria-expanded="false" disabled>
                            <span>‚èπ</span>
                            <span id="cancelBtnText">Cancel Mission</span>
                        </button>
                        <ul class="dropdown-menu" id="cancelDropdown">
                            <li><a class="dropdown-item" href="#" onclick="cancelMission('NORMAL'); return false;">
                                <strong>NORMAL</strong><br>
                                <small class="text-muted">Standard cancellation</small>
                            </a></li>
                            <li><a class="dropdown-item" href="#" onclick="cancelMission('FORCE'); return false;">
                                <strong>FORCE</strong><br>
                                <small class="text-muted">Force stop immediately</small>
                            </a></li>
                            <li><a class="dropdown-item" href="#" onclick="cancelMission('REDIRECT_START'); return false;">
                                <strong>REDIRECT_START</strong><br>
                                <small class="text-muted">Cancel and redirect to start</small>
                            </a></li>
                        </ul>
                    </div>
                </div>

                <!-- Mission Info Section -->
                <div class="control-section">
                    <h3 class="control-section-title">Mission Details</h3>
                    <div class="mission-info">
                        <div class="mission-info-row">
                            <span class="mission-info-label">Type:</span>
                            <span class="mission-info-value">@Model.Mission.MissionType</span>
                        </div>
                        <div class="mission-info-row">
                            <span class="mission-info-label">Robot Type:</span>
                            <span class="mission-info-value">@Model.Mission.RobotType</span>
                        </div>
                        <div class="mission-info-row">
                            <span class="mission-info-label">Priority:</span>
                            <span class="mission-info-value">@Model.Mission.Priority</span>
                        </div>
                        <div class="mission-info-row">
                            <span class="mission-info-label">Steps:</span>
                            <span class="mission-info-value">@Model.Mission.Steps.Count</span>
                        </div>
                        @if (!string.IsNullOrEmpty(Model.Mission.RobotIds))
                        {
                            <div class="mission-info-row">
                                <span class="mission-info-label">Robot IDs:</span>
                                <span class="mission-info-value">@Model.Mission.RobotIds</span>
                            </div>
                        }
                    </div>
                </div>
            </div>
        </div>
    }
</div>

<!-- Toast Notification Container -->
<div class="toast-container position-fixed top-0 end-0 p-3" style="z-index: 9999;">
    <!-- Toasts will be inserted here dynamically -->
</div>

<!-- Manual Waypoint Modal -->
<div class="modal fade" id="manualWaypointModal" tabindex="-1" aria-labelledby="manualWaypointModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header bg-warning text-dark">
                <h5 class="modal-title" id="manualWaypointModalLabel">
                    üõë Robot Waiting at Manual Waypoint
                </h5>
            </div>
            <div class="modal-body">
                <div class="alert alert-warning">
                    <strong>Action Required:</strong> The robot has reached a manual waypoint and is waiting for you to complete the manual task.
                </div>

                <dl class="row mb-0">
                    <dt class="col-sm-4">Mission Code:</dt>
                    <dd class="col-sm-8"><strong id="modalMissionCode">-</strong></dd>

                    <dt class="col-sm-4">Current Position:</dt>
                    <dd class="col-sm-8"><strong id="modalPosition">-</strong></dd>

                    <dt class="col-sm-4">Robot ID:</dt>
                    <dd class="col-sm-8"><strong id="modalRobotId">-</strong></dd>

                    <dt class="col-sm-4">Battery Level:</dt>
                    <dd class="col-sm-8">
                        <span id="modalBattery">-</span>%
                        <div class="progress mt-1" style="height: 10px;">
                            <div id="modalBatteryBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                        </div>
                    </dd>
                </dl>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-success w-100" id="resumeBtn" onclick="resumeMission()">
                    <span class="btn-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
                        </svg>
                    </span>
                    <span class="resume-btn-text">Resume Mission</span>
                    <span class="spinner-border spinner-border-sm d-none" role="status"></span>
                </button>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>

    <script>
        // Mission and Map Zone data from server
        const missionId = @(Model.Mission?.Id ?? 0);
        const missionSteps = @Html.Raw(Json.Serialize(Model.Mission?.Steps ?? new List<WorkflowMonitorModel.MissionStepDto>()));
        const mapZones = @Html.Raw(Json.Serialize(Model.MapZones ?? new List<WorkflowMonitorModel.WorkflowMonitorMapZoneSummaryDto>()));
        const pollingInterval = @Model.PollingIntervalSeconds * 1000;

        // Create a map of zone codes to names for display purposes
        const zoneCodeToNameMap = {};
        if (mapZones && Array.isArray(mapZones)) {
            mapZones.forEach(zone => {
                zoneCodeToNameMap[zone.ZoneCode] = zone.ZoneName;
            });
        }

        // Helper function to get display name for position (zone code -> zone name, or just return the value for node points)
        function getDisplayPosition(position) {
            if (position && zoneCodeToNameMap[position]) {
                return zoneCodeToNameMap[position];
            }
            return position;
        }

        // State
        let currentLayout = 'TD';
        let currentMissionCode = null;
        let currentRobotId = null;  // Track current robot ID
        let pollingIntervalId = null;
        let isPolling = false;

        // SessionStorage keys
        const ACTIVE_MISSION_KEY = 'workflowMonitor_activeMission';

        // Track step states for visual highlighting
        const stepStates = {
            current: null,           // Currently at this step
            completed: new Set(),    // Steps already visited
            pending: new Set()       // Steps not yet reached
        };

        // Initialize step states from mission steps
        if (missionSteps && missionSteps.length > 0) {
            missionSteps.forEach(step => {
                stepStates.pending.add(step.sequence);
            });
        }

        // SessionStorage helpers
        function saveActiveMission(missionCode) {
            sessionStorage.setItem(ACTIVE_MISSION_KEY, JSON.stringify({
                missionId: missionId,
                missionCode: missionCode,
                startTime: new Date().toISOString()
            }));
        }

        function getActiveMission() {
            const saved = sessionStorage.getItem(ACTIVE_MISSION_KEY);
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    // Only return if it's for this mission
                    if (data.missionId === missionId) {
                        return data;
                    }
                } catch (e) {
                    console.error('Error parsing saved mission:', e);
                }
            }
            return null;
        }

        function clearActiveMission() {
            sessionStorage.removeItem(ACTIVE_MISSION_KEY);
        }

        // Initialize Mermaid
        mermaid.initialize({
            startOnLoad: false,
            theme: 'default',
            themeVariables: {
                primaryColor: '#667eea',
                primaryTextColor: '#fff',
                primaryBorderColor: '#764ba2',
                lineColor: '#667eea',
                secondaryColor: '#e2e8f0',
                tertiaryColor: '#f7fafc'
            },
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis',
                padding: 20,
                nodeSpacing: 50,
                rankSpacing: 80
            }
        });

        // Render flowchart on page load
        document.addEventListener('DOMContentLoaded', async function() {
            // DEBUG: Log the mission steps data
            console.log('=== WORKFLOW MONITOR DEBUG ===');
            console.log('Mission ID:', missionId);
            console.log('Mission Steps Count:', missionSteps ? missionSteps.length : 0);
            console.log('Mission Steps Data:', JSON.stringify(missionSteps, null, 2));

            if (missionSteps && missionSteps.length > 0) {
                console.log('First step:', missionSteps[0]);
                console.log('- sequence:', missionSteps[0].sequence);
                console.log('- position:', missionSteps[0].position);
                console.log('- putDown:', missionSteps[0].putDown);
                console.log('- type:', missionSteps[0].type);
            }
            console.log('==============================');

            renderFlowchart();

            // Check for active mission on page load
            await checkInitialMissionStatus();
        });

        async function checkInitialMissionStatus() {
            try {
                // First, check sessionStorage for saved mission
                const savedMission = getActiveMission();
                if (savedMission) {
                    console.log('Found saved mission in sessionStorage:', savedMission);
                    currentMissionCode = savedMission.missionCode;
                }

                // Then check with backend for actual queue status
                const response = await fetch(`?handler=QueueStatus&id=${missionId}`);
                if (response.ok) {
                    const data = await response.json();
                    console.log('Queue status check:', data);

                    if (data.success && data.isActive && data.missionCode) {
                        // Mission is active in the queue
                        currentMissionCode = data.missionCode;
                        saveActiveMission(data.missionCode);

                        // Update button states
                        document.getElementById('startBtn').disabled = true;
                        document.getElementById('cancelBtn').disabled = false;

                        // Start polling (manual waypoint now handled inline)
                        startPolling();

                        console.log('Restored active mission:', data.missionCode);
                    } else if (!data.isActive && savedMission) {
                        // Mission was in sessionStorage but not active anymore
                        clearActiveMission();
                        currentMissionCode = null;
                        console.log('Cleared stale mission from sessionStorage');
                    }
                }
            } catch (error) {
                console.error('Error checking initial mission status:', error);
            }
        }

        async function renderFlowchart() {
            const container = document.getElementById('flowchartContainer');

            if (!missionSteps || missionSteps.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üìã</div><p>No mission steps defined</p></div>';
                return;
            }

            container.innerHTML = '<div class="empty-state"><div class="spinner"></div><p style="margin-top: 16px;">Rendering flowchart...</p></div>';

            try {
                const flowchartHtml = await renderMermaidFlowchart(missionSteps, currentLayout);
                container.innerHTML = flowchartHtml;
            } catch (error) {
                console.error('Error rendering flowchart:', error);
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">‚ö†Ô∏è</div><p>Error rendering flowchart</p></div>';
            }
        }

        async function renderMermaidFlowchart(steps, direction = 'TD') {
            if (!steps || steps.length === 0) {
                return '<div class="preview-empty">No mission steps defined</div>';
            }

            // Generate unique ID for this diagram
            const diagramId = 'mermaid-' + Date.now();

            // Build Mermaid syntax - EXACT SAME AS CUSTOMMISSION
            let mermaidCode = `graph ${direction}\n`;

            // START node
            mermaidCode += '    START([üöÄ START])\n';
            mermaidCode += '    style START fill:#667eea,stroke:#764ba2,stroke-width:3px,color:#fff\n';

            // Add each step
            steps.forEach((step, index) => {
                const stepId = `S${step.sequence}`;
                const prevId = index === 0 ? 'START' : `S${steps[index - 1].sequence}`;

                // Determine action icon and text
                const actionIcon = step.putDown ? 'üîΩ' : 'üîº';
                const actionText = step.putDown ? 'Drop' : 'Pick';

                // Build label with line breaks
                let label = `"<b>${step.sequence}</b>: ${getDisplayPosition(step.position)}`;
                label += `<br/>${actionIcon} ${actionText}`;

                if (step.waitingMillis > 0) {
                    const waitText = step.waitingMillis >= 1000
                        ? `${(step.waitingMillis / 1000).toFixed(1)}s`
                        : `${step.waitingMillis}ms`;
                    label += `<br/>‚è±Ô∏è ${waitText}`;
                }

                label += `"`;

                // Add step node
                mermaidCode += `    ${stepId}[${label}]\n`;

                // Add connection from previous
                mermaidCode += `    ${prevId} --> ${stepId}\n`;

                // Enhanced styling based on step state (using sequences for consistency)
                if (stepStates.current === step.sequence) {
                    // CURRENT STEP - Bright yellow with thick orange border
                    mermaidCode += `    style ${stepId} fill:#fffbeb,stroke:#f59e0b,stroke-width:5px,color:#1f2937\n`;
                } else if (stepStates.completed.has(step.sequence)) {
                    // COMPLETED STEP - Green with checkmark
                    label = `"<b>${step.sequence}</b>: ${getDisplayPosition(step.position)}`;
                    label += `<br/>‚úÖ ${actionText}`;
                    if (step.waitingMillis > 0) {
                        const waitText = step.waitingMillis >= 1000
                            ? `${(step.waitingMillis / 1000).toFixed(1)}s`
                            : `${step.waitingMillis}ms`;
                        label += `<br/>‚è±Ô∏è ${waitText}`;
                    }
                    label += `"`;
                    mermaidCode += `    ${stepId}[${label}]\n`;
                    mermaidCode += `    style ${stepId} fill:#d1fae5,stroke:#10b981,stroke-width:2px,color:#065f46\n`;
                } else {
                    // PENDING STEP - Gray
                    mermaidCode += `    style ${stepId} fill:#f3f4f6,stroke:#9ca3af,stroke-width:2px,color:#6b7280\n`;
                }
            });

            // END node
            const lastStepId = `S${steps[steps.length - 1].sequence}`;
            mermaidCode += '    END([üéØ END])\n';
            mermaidCode += `    ${lastStepId} --> END\n`;
            mermaidCode += '    style END fill:#10b981,stroke:#059669,stroke-width:3px,color:#fff\n';

            // Create container and render
            try {
                const { svg } = await mermaid.render(diagramId, mermaidCode);
                return `<div class="mermaid-container">${svg}</div>`;
            } catch (error) {
                console.error('Mermaid rendering error:', error);
                return `<div class="preview-empty">Error rendering flowchart: ${error.message}</div>`;
            }
        }

        function toggleLayout() {
            currentLayout = currentLayout === 'TD' ? 'LR' : 'TD';

            const iconEl = document.getElementById('layoutIcon');
            const textEl = document.getElementById('layoutText');

            if (currentLayout === 'TD') {
                iconEl.textContent = '‚¨ç';
                textEl.textContent = 'Horizontal';
            } else {
                iconEl.textContent = '‚¨å';
                textEl.textContent = 'Vertical';
            }

            renderFlowchart();
        }

        async function startMission() {
            const startBtn = document.getElementById('startBtn');
            const startBtnText = document.getElementById('startBtnText');
            const startSpinner = document.getElementById('startSpinner');

            startBtn.disabled = true;
            startBtnText.textContent = 'Starting...';
            startSpinner.style.display = 'block';

            try {
                const response = await fetch('?handler=Start', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ savedMissionId: missionId })
                });

                // Check if response is ok
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Server error:', response.status, errorText);
                    showNotification(`Server error (${response.status}): ${errorText || 'Failed to start mission'}`, 'error');
                    startBtn.disabled = false;
                    startBtnText.textContent = 'Start Mission';
                    startSpinner.style.display = 'none';
                    return;
                }

                // Try to parse JSON
                let result;
                try {
                    result = await response.json();
                } catch (jsonError) {
                    console.error('JSON parse error:', jsonError);
                    showNotification('Invalid response from server', 'error');
                    startBtn.disabled = false;
                    startBtnText.textContent = 'Start Mission';
                    startSpinner.style.display = 'none';
                    return;
                }

                if (result.success) {
                    currentMissionCode = result.missionCode;
                    showNotification(`Mission started: ${result.missionCode}`, 'success');

                    // Save to sessionStorage
                    saveActiveMission(result.missionCode);

                    // Reset progress display for new mission
                    const stepProgressElement = document.getElementById('stepProgress');
                    const currentPositionElement = document.getElementById('currentPosition');
                    const batteryLevelElement = document.getElementById('batteryLevel');
                    if (stepProgressElement) stepProgressElement.textContent = '-';
                    if (currentPositionElement) currentPositionElement.textContent = '-';
                    if (batteryLevelElement) batteryLevelElement.textContent = '-';

                    // Keep start button disabled (mission is now active)
                    // startBtn.disabled remains true

                    // Enable cancel button
                    document.getElementById('cancelBtn').disabled = false;

                    // Start polling
                    startPolling();  // Manual waypoint now handled inline
                } else {
                    showNotification(result.message || 'Failed to start mission', 'error');
                    startBtn.disabled = false;
                }
            } catch (error) {
                console.error('Error starting mission:', error);
                showNotification(`Error: ${error.message}`, 'error');
                startBtn.disabled = false;
            } finally {
                startBtnText.textContent = 'Start Mission';
                startSpinner.style.display = 'none';
            }
        }

        async function cancelMission(cancelMode = 'NORMAL') {
            if (!currentMissionCode) {
                showNotification('No active mission to cancel', 'warning');
                return;
            }

            // Confirm cancel action
            const modeDescriptions = {
                'NORMAL': 'standard cancellation',
                'FORCE': 'force stop immediately',
                'REDIRECT_START': 'cancel and redirect to start'
            };
            const confirmMsg = `Cancel mission ${currentMissionCode} with ${modeDescriptions[cancelMode]}?`;
            if (!confirm(confirmMsg)) {
                return;
            }

            const cancelBtn = document.getElementById('cancelBtn');
            const cancelBtnText = document.getElementById('cancelBtnText');

            const originalText = cancelBtnText.textContent;
            cancelBtn.disabled = true;
            cancelBtnText.textContent = `Cancelling (${cancelMode})...`;

            try {
                const response = await fetch('?handler=Cancel', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        missionCode: currentMissionCode,
                        cancelMode: cancelMode,
                        reason: `User cancelled via WorkflowMonitor with mode: ${cancelMode}`
                    })
                });

                // Check if response is ok
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Server error:', response.status, errorText);
                    showNotification(`Server error (${response.status}): Failed to cancel`, 'error');
                    cancelBtn.disabled = false;
                    cancelBtnText.textContent = originalText;
                    return;
                }

                // Try to parse JSON
                let result;
                try {
                    result = await response.json();
                } catch (jsonError) {
                    console.error('JSON parse error:', jsonError);
                    showNotification('Invalid response from server', 'error');
                    cancelBtn.disabled = false;
                    cancelBtnText.textContent = originalText;
                    return;
                }

                if (result.success) {
                    showNotification(`Mission cancelled (${cancelMode}): ${currentMissionCode}`, 'success');
                    // Status polling will detect the cancellation

                    // Clear robot ID on cancel
                    currentRobotId = null;
                } else {
                    showNotification(result.message || 'Failed to cancel mission', 'error');
                    cancelBtn.disabled = false;
                }
            } catch (error) {
                console.error('Error cancelling mission:', error);
                showNotification(`Error: ${error.message}`, 'error');
                cancelBtn.disabled = false;
            } finally {
                cancelBtnText.textContent = originalText;
            }
        }

        function startPolling() {
            if (isPolling) return;

            isPolling = true;
            updateStatus(); // Poll immediately

            pollingIntervalId = setInterval(updateStatus, pollingInterval);
        }

        function stopPolling() {
            if (pollingIntervalId) {
                clearInterval(pollingIntervalId);
                pollingIntervalId = null;
            }
            isPolling = false;
        }

        async function updateStatus() {
            try {
                // Build query string with robotId if available
                let queryParams = `id=${missionId}&missionCode=${currentMissionCode || ''}`;
                if (currentRobotId) {
                    queryParams += `&robotId=${encodeURIComponent(currentRobotId)}`;
                }

                const response = await fetch(`?handler=Status&${queryParams}`);
                const data = await response.json();

                if (data.success) {
                    // Store robotId from backend for next call
                    if (data.robotId) {
                        currentRobotId = data.robotId;
                    }

                    updateStatusDisplay(data);

                    // Always update flowchart when we have data
                    updateFlowchartProgress(data);
                    updateStepDetails(data);

                    // Handle manual waypoint (consolidated from separate polling)
                    if (data.isWaitingAtManualWaypoint && data.manualWaypointData) {
                        // Check if this is a new or different waiting mission
                        if (!currentWaitingMission || currentWaitingMission.missionCode !== data.manualWaypointData.missionCode) {
                            showManualWaypointModal(data.manualWaypointData);
                        } else {
                            // Same mission still waiting - update modal data
                            updateModalData(data.manualWaypointData);
                        }
                    } else if (currentWaitingMission) {
                        // Was waiting but no longer - hide modal
                        hideManualWaypointModal();
                    }

                    // Stop polling if terminal
                    if (data.isTerminal) {
                        // Update progress to show completion before stopping
                        const stepProgressElement = document.getElementById('stepProgress');
                        if (stepProgressElement && data.totalSteps > 0) {
                            if (data.statusName === 'Completed') {
                                stepProgressElement.textContent = `Completed (${data.totalSteps} steps)`;
                            } else if (data.statusName === 'Cancelled') {
                                stepProgressElement.textContent = `Cancelled`;
                            } else if (data.statusName === 'Failed') {
                                stepProgressElement.textContent = `Failed`;
                            }
                        }

                        stopPolling();
                        document.getElementById('startBtn').disabled = false;
                        document.getElementById('cancelBtn').disabled = true;

                        // Clear sessionStorage when mission is complete
                        clearActiveMission();
                        currentMissionCode = null;
                        currentRobotId = null;

                        if (data.statusName === 'Completed') {
                            showNotification('Mission completed successfully!', 'success');
                        }
                    }
                }
            } catch (error) {
                console.error('Error polling status:', error);
            }
        }

        function updateFlowchartProgress(backendData) {
            const newStepIndex = backendData.currentStepIndex;
            const newStep = backendData.currentStep;
            const newSequence = newStep?.sequence || null;

            // Only update if there's a change (using sequences for consistency)
            if (newSequence !== null && newSequence === stepStates.current) {
                return; // No change
            }

            const previousSequence = stepStates.current;

            // Mark previous step as completed (if it exists and is different)
            if (previousSequence !== null && newSequence !== null && previousSequence !== newSequence) {
                stepStates.completed.add(previousSequence);
                stepStates.pending.delete(previousSequence);
            }

            // Mark new current step (store sequence, not index)
            if (newSequence !== null) {
                stepStates.current = newSequence;
                stepStates.pending.delete(newSequence);

                // Show notification if robot moved to a new step
                if (previousSequence !== newSequence && newStep) {
                    const stepNumber = newStep.sequence;
                    const position = newStep.position;
                    const actionText = newStep.putDown ? 'Drop' : 'Pick';

                    showNotification(
                        `ü§ñ Robot reached step ${stepNumber}: ${getDisplayPosition(position)} (${actionText})`,
                        'info'
                    );
                }
            } else {
                stepStates.current = null;
            }

            // Re-render flowchart with new states
            renderFlowchart();
        }

        function updateStepDetails(data) {
            const stepDetailsContainer = document.getElementById('currentStepDetails');
            if (!stepDetailsContainer) {
                return;
            }

            if (!data.currentStep) {
                stepDetailsContainer.style.display = 'none';
                return;
            }

            stepDetailsContainer.style.display = 'block';

            const step = data.currentStep;
            const actionText = step.putDown ? 'üîΩ Drop' : 'üîº Pick';

            stepDetailsContainer.innerHTML = `
                <div class="current-step-card">
                    <h4>Current Step (${step.sequence})</h4>
                    <div class="step-info">
                        <strong>Position:</strong> ${getDisplayPosition(step.position)}
                        ${data.matchType ? `<small class="text-muted">(${data.matchType})</small>` : ''}
                    </div>
                    <div class="step-info">
                        <strong>Action:</strong> ${actionText}
                    </div>
                    <div class="step-info">
                        <strong>Type:</strong> ${step.type}
                    </div>
                    ${step.passStrategy === 'MANUAL' ? '<div class="manual-notice">‚ö†Ô∏è Manual intervention required</div>' : ''}
                    <div class="step-info">
                        <strong>Node Code:</strong> <code>${data.currentNodeCode || 'N/A'}</code>
                    </div>
                </div>
            `;
        }

        function updateStatusDisplay(data) {
            const statusBadge = document.getElementById('statusBadge');
            const statusIcon = document.getElementById('statusIcon');
            const statusText = document.getElementById('statusText');
            const robotId = document.getElementById('robotId');
            const currentPosition = document.getElementById('currentPosition');
            const stepProgress = document.getElementById('stepProgress');
            const batteryLevel = document.getElementById('batteryLevel');
            const duration = document.getElementById('duration');

            // Update status
            statusText.textContent = data.statusName;
            statusBadge.className = `status-badge ${data.cssClass}`;

            // Update icon based on status
            const icons = {
                'idle': '‚èπ',
                'Idle': '‚èπ',
                'Queued': '‚è±',
                'Running': '‚ñ∂Ô∏è',
                'Waiting': '‚è∏',
                'Completed': '‚úÖ',
                'Cancelled': '‚ùå',
                'Failed': '‚ö†Ô∏è'
            };
            statusIcon.textContent = icons[data.statusName] || 'üîÑ';

            // Update details
            robotId.textContent = data.robotId || '-';

            // Update position
            currentPosition.textContent = data.currentNodeCode || (data.currentStep ? data.currentStep.position : '-');

            // Update progress (don't overwrite terminal state messages)
            if (!data.isTerminal) {
                if (data.currentStepIndex !== null && data.totalSteps && data.totalSteps > 0) {
                    stepProgress.textContent = `Step ${data.currentStepIndex + 1} of ${data.totalSteps}`;
                } else {
                    stepProgress.textContent = '-';
                }
            }
            // Terminal state progress is handled in updateStatus() terminal handler

            // Update battery
            if (data.batteryLevel !== null && data.batteryLevel !== undefined) {
                batteryLevel.textContent = `${data.batteryLevel}%`;
            } else {
                batteryLevel.textContent = '-';
            }

            duration.textContent = data.spendTime ? `${data.spendTime}s` : '-';
        }

        function showNotification(message, type = 'info') {
            const icons = {
                success: '‚úÖ',
                error: '‚ùå',
                warning: '‚ö†Ô∏è',
                info: '‚ÑπÔ∏è'
            };

            const bgColors = {
                success: 'bg-success',
                error: 'bg-danger',
                warning: 'bg-warning',
                info: 'bg-info'
            };

            const textColors = {
                success: 'text-white',
                error: 'text-white',
                warning: 'text-dark',
                info: 'text-white'
            };

            // Create unique ID for this toast
            const toastId = `toast-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

            // Create toast element
            const toastHtml = `
                <div id="${toastId}" class="toast align-items-center ${bgColors[type]} ${textColors[type]} border-0" role="alert" aria-live="assertive" aria-atomic="true">
                    <div class="d-flex">
                        <div class="toast-body">
                            ${icons[type]} ${message}
                        </div>
                        <button type="button" class="btn-close btn-close-${type === 'warning' ? 'dark' : 'white'} me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                    </div>
                </div>
            `;

            // Add toast to container
            const container = document.querySelector('.toast-container');
            container.insertAdjacentHTML('beforeend', toastHtml);

            // Get the toast element and show it
            const toastElement = document.getElementById(toastId);
            const toast = new bootstrap.Toast(toastElement, {
                autohide: true,
                delay: type === 'error' ? 5000 : 3000  // Errors stay longer
            });

            toast.show();

            // Remove from DOM after hidden
            toastElement.addEventListener('hidden.bs.toast', () => {
                toastElement.remove();
            });
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            stopPolling();
        });

        // ========================================
        // MANUAL WAYPOINT HANDLING
        // ========================================
        // NOTE: Separate polling has been consolidated into main status polling.
        // Manual waypoint detection now happens in updateStatus() via backend response.

        let modalInstance = null;
        let currentWaitingMission = null;

        // DEPRECATED: These polling functions are no longer used (consolidated into updateStatus)
        // Keeping as comments for reference:
        /*
        const MANUAL_WAYPOINT_CHECK_INTERVAL_MS = 5000;
        let manualWaypointCheckInterval = null;

        function startManualWaypointCheck() { ... }
        function stopManualWaypointCheck() { ... }
        async function checkForManualWaypoint() { ... }
        */

        function showManualWaypointModal(mission) {
            currentWaitingMission = mission;
            console.log(`üì¢ Showing manual waypoint modal for ${mission.missionCode}`);

            // Update modal data
            updateModalData(mission);

            // Show modal
            if (!modalInstance) {
                const modalElement = document.getElementById('manualWaypointModal');
                modalInstance = new bootstrap.Modal(modalElement);
            }

            modalInstance.show();

            // Play notification sound (optional)
            playNotificationSound();

            // NOTE: No longer stopping polling - waypoint status now integrated into main polling
        }

        function updateModalData(mission) {
            document.getElementById('modalMissionCode').textContent = mission.missionCode || '-';
            document.getElementById('modalPosition').textContent = mission.currentPosition || '-';
            document.getElementById('modalRobotId').textContent = mission.robotId || '-';

            const battery = mission.batteryLevel || 0;
            document.getElementById('modalBattery').textContent = battery;

            const batteryBar = document.getElementById('modalBatteryBar');
            batteryBar.style.width = `${battery}%`;

            // Color code battery level
            if (battery > 50) {
                batteryBar.className = 'progress-bar bg-success';
            } else if (battery > 20) {
                batteryBar.className = 'progress-bar bg-warning';
            } else {
                batteryBar.className = 'progress-bar bg-danger';
            }
        }

        function hideManualWaypointModal() {
            if (modalInstance) {
                modalInstance.hide();
            }
            console.log('Modal hidden');
            currentWaitingMission = null;

            // NOTE: No longer need to restart polling - it's already running
        }

        async function resumeMission() {
            if (!currentWaitingMission) {
                showNotification('No mission to resume', 'warning');
                return;
            }

            console.log(`‚ñ∂Ô∏è User clicked Resume for ${currentWaitingMission.missionCode}`);

            const resumeBtn = document.getElementById('resumeBtn');
            const btnText = resumeBtn.querySelector('.resume-btn-text');
            const spinner = resumeBtn.querySelector('.spinner-border');

            resumeBtn.disabled = true;
            btnText.textContent = 'Resuming...';
            spinner.classList.remove('d-none');

            try {
                const apiUrl = `?handler=ResumeManualWaypoint&missionCode=${encodeURIComponent(currentWaitingMission.missionCode)}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        missionCode: currentWaitingMission.missionCode
                    })
                });

                const result = await response.json();

                if (result.success) {
                    showNotification(`Mission resumed successfully! RequestID: ${result.requestId}`, 'success');
                    console.log(`‚úÖ Mission resumed! RequestID: ${result.requestId}`);
                    hideManualWaypointModal();

                    // Status will be updated automatically in next polling cycle
                } else {
                    showNotification(result.message || 'Failed to resume mission', 'error');
                    console.error('Resume failed:', result.message);
                }
            } catch (error) {
                console.error('Error resuming mission:', error);
                showNotification('Network error. Please try again.', 'error');
            } finally {
                resumeBtn.disabled = false;
                btnText.textContent = 'Resume Mission';
                spinner.classList.add('d-none');
            }
        }

        function playNotificationSound() {
            // Optional: Play a notification sound
            try {
                const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBTGH0fPTgjMGHm7A7+OZUA0PVqzn77BfHAU7k9n0yXkrBSZ4yPDcjUUMFmS56+mjUhIOT6Xh8rdmIAU1j9Pzz4IyBiBuwO/jmE8NDVat5++wXx0FO5PZ9Ml5KwUmeMjw3I1FDBZkuevpo1ISDk+l4fK3ZiAFNY/U88+CMgYgb8Hv4pZPDANVrOjur18cBjuU2vXJeSwGJnjJ8N2NRRIUZ7rq6qFRDw5PpeHxtWcgBDWP0/PPgjIGIG/C8OOXTwwDVazn7rBfHQU7lNr1yXksBSZ4yfDejUUSFGe76+qhUQ8OT6Xh8rVnIAQ1j9Pz0IIyBiFvwvDjl04MA1Ws5+6wXx0FO5Ta9Ml5LQUmeMrw3Y1GEhRnuuvqoVEPDk6l4fK2ZyAENY/U89CCMwYhb8Lw45dODANVrefur18dBTuU2vXJeS0FJnnK8N2NRhIUZ7rs6qFRDw5OpOHztmlhBDWQ0/TPgjMHIW/D8eSXTgwDVq3n76xfHAY7lNr1ynksBSd5y/DejUcSFme67OqgURAOTqPh87ZpYQQ1kNPzz4IzByFvw/HklUkMA1at5++sYBwGO5Tb9cp5LAUnecrx3o1GEhZnuu3qoVIQDk6k4PK2aWAENY/T88+DMwchb8Lx5JVJDANWrefvrGAcBjyU2/XKeSwFJ3nK8d6NRhIWZ7rt6qFSEA5OpODytWlgBDWQ1PPPgzMHIm/C8eOUSQwDV63n7q1gHAY8lNv1ynksBSd5yvHejUYSFme67eqhURAOTqTg8rVpYAQ1kNTzz4MzByJvwvHjlEkMA1et5++tYBwGPJTb9cp5LAUnecvx3o1HERBH');
                audio.play().catch(e => console.log('Could not play notification sound:', e));
            } catch (e) {
                console.log('Notification sound error:', e);
            }
        }
    </script>
}
